### Отчёт по лабораторной: Моделирование полёта тела в атмосфере

**Задание:**  
Реализовать приложение для моделирования полёта тела в атмосфере.  
Предусмотреть возможность ввода шага моделирования и вывода результатов.
Выполнить моделирование **без очистки предыдущих результатов** для различных шагов моделирования, сравнить траектории и заполнить таблицу.
Сделать выводы.

---

# Код программы:
Импорт библиотек и константы:

    import numpy as np
    import matplotlib.pyplot as plt
    from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
    from matplotlib.figure import Figure
    import tkinter as tk
    from tkinter import ttk, messagebox

    G = 9.81 
    RHO = 1.225  
    C = 0.15 

# Вычисление ускорения
# КАРТИНКА
    # Вычисляет производные: [dx/dt, dy/dt, dvx/dt, dvy/dt]
    def get_derivatives(state, m, S):
        x, y, vx, vy = state
        v = np.sqrt(vx**2 + vy**2) # модуль вектора скорости
        k = C * RHO * S / (2*m) # Баллистический коэффициент

        # ускорения
        ax = -k * vx * v
        ay = -G - k * vy * v
        return np.array([vx, vy, ax, ay])


# Один шаг полёта
# КАРТИНКА
    def step_RungeKutta_4(state, dt, m, S):
        k1 = get_derivatives(state, m, S)
        k2 = get_derivatives(state + k1 * dt / 2, m, S)
        k3 = get_derivatives(state + k2 * dt / 2, m, S)
        k4 = get_derivatives(state + k3 * dt, m, S)
        
        new_state = state + (k1 + 2*k2 + 2*k3 + k4) * dt / 6 # где мы?
        return new_state


# Симуляция полёта
# КАРТИНКА
    def simulate(v0, angle, dt, m, S):
        # начальные условия
        angle_rad = np.radians(angle)
        vx = v0 * np.cos(angle_rad)
        vy = v0 * np.sin(angle_rad)
        
        # [x, y, vx, vy]
        state = np.array([0.0, 0.0, vx, vy])
        
        # инфа о пути
        traj_x, traj_y = [0.0], [0.0]
        max_h = 0.0

        while state[1] >= 0: # пока не упало
            state = step_RungeKutta_4(state, dt, m, S)
            if state[1] >= 0:
                traj_x.append(state[0])
                traj_y.append(state[1])
                max_h = max(max_h, state[1])

        final_v = np.sqrt(state[2]**2 + state[3]**2)
        return traj_x, traj_y, state[0], max_h, final_v

Скриншот с несколькими траекториями:

# КАРТИНКА
---

Заполненная таблица:

|Шаг моделирования, с|1|0.1|0.01|0.001|0.0001|
|-|-|-|-|-|-|
| Дальность полёта, м | 253.53 | 247.28 | 246.34 | 246.31 | 246.30 |
| Максимальная высота, м | 73.93 | 74.00 | 74.01 | 74.01 | 74.01 |
| Скорость в конечной точке, м/с | 50.87 | 49.38 | 49.16 | 49.15 | 49.15 |

---
Вывод:
В ходе работы было реализовано приложение для моделирования полёта тела в атмосфере с предусмотренной возможность ввода шага моделирования и вывода результатов(в том числе в сразу табличном, необходимом для лабораторной, виде)

В коде для моделирования полёта тела был использован метод Рунге-Кутты 4 порядка из-за его большей точности, нежели у метода Эйлера(сходимость у РК значительно быстрее, чем у Эйлера). Это объясняется тем, что Эйлер используетс только одну производную в начале шага, грубо говоря, смотрит наклон и идёт прямо, а в РК4 вычисляется одна и та же производная, но уже в разных точках шага, и с помощью них строит плавную и точную кривую.

На заполненной таблице видно, как существенно отличаются между друг другом только первый и второй шаг(там уже почти достигнут точный результат). Далее результаты выходят практически те же самые, меняясь лишь в сотых значениях. Тем не менее из разницы между первым и вторым измерениями можно сделать вывод, что шаг времени напрямую влияет на точность полученных результатов.











